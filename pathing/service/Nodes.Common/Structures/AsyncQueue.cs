using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Nodes.Structures
{
  /// <summary>
  /// http://stackoverflow.com/questions/7863573/awaitable-task-based-queue
  /// </summary>
  /// <typeparam name="T"></typeparam>
  public class AsyncQueue<T>
  {
    private readonly ConcurrentQueue<T> _bufferQueue;
    private readonly ConcurrentQueue<TaskCompletionSource<T>> _promisesQueue;
    private readonly object _syncRoot = new object();

    public AsyncQueue()
    {
      _bufferQueue = new ConcurrentQueue<T>();
      _promisesQueue = new ConcurrentQueue<TaskCompletionSource<T>>();
    }

    /// <summary>
    /// Enqueues the specified item.
    /// </summary>
    /// <param name="item">The item.</param>
    public void Enqueue(T item)
    {
      TaskCompletionSource<T> promise;
      do
      {
        lock (_syncRoot) {
          if (_promisesQueue.TryDequeue(out promise) &&
              !promise.Task.IsCanceled &&
              promise.TrySetResult(item))
          {
            return;
          }
        }
      }
      while (promise != null);

      lock (_syncRoot)
      {
        if (_promisesQueue.TryDequeue(out promise) &&
            !promise.Task.IsCanceled &&
            promise.TrySetResult(item))
        {
          return;
        }

        _bufferQueue.Enqueue(item);
      }
    }

    public override string ToString() {
      return $"<AV={_bufferQueue.Count}/WT={_promisesQueue.Count}>";
    }

    /// <summary>
    /// Dequeues the asynchronous.
    /// </summary>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns></returns>
    public Task<T> DequeueAsync(CancellationToken cancellationToken)
    {
      T item;

      if (!_bufferQueue.TryDequeue(out item))
      {
        lock (_syncRoot)
        {
          if (!_bufferQueue.TryDequeue(out item))
          {
            var promise = new TaskCompletionSource<T>();
            cancellationToken.Register(() => promise.TrySetCanceled());

            _promisesQueue.Enqueue(promise);
            PromiseAdded?.Invoke(this, EventArgs.Empty);

            return promise.Task;
          }
        }
      }

      return Task.FromResult(item);
    }

    /// <summary>
    /// Gets a value indicating whether this instance has promises.
    /// </summary>
    /// <value>
    /// <c>true</c> if this instance has promises; otherwise, <c>false</c>.
    /// </value>
    public bool HasPromises
    {
      get
      {
        lock (_syncRoot) {
          return _promisesQueue.Any(p => !p.Task.IsCanceled);
        }
      }
    }

    /// <summary>
    /// Occurs when a new promise
    /// is generated by the queue
    /// </summary>
    public event EventHandler PromiseAdded;
  }
}
